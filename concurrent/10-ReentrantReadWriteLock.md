# ReentrantReadWriteLock

## 1，读写锁介绍

​		对共享资源有读和写的操作，在没有写操作的时候，多个线程同时读一个资源没有任何问题；但是如果一个线程想去写这些共享资源，就不应该允许其他线程对该资源进行读和写操作了（读写，写读，写写互斥）。在读多于写的情况下，读写锁能够提供比排它锁更好的并发性和吞吐量。

​		这里包含了共享锁（读锁-多个读线程可同时读），独占锁（写锁-只允许一个读线程），JAVA的并发包提供了读写锁ReentrantReadWriteLock，它内部，维护了一对相关的锁，一个用于只读操作，称为读锁；一个用于写入操作，称为写锁。

**线程进入读锁的前提条件**：

-   此刻没有写线程占有锁
-   没有写请求，或者有写请求但调用线程和持有锁的线程是同一个（写优先）

**线程进入写锁的前提条件**：

-   没有线程持有读锁
-   没有线程持有写锁

**读写锁三个重要特性**：

-   公平选择性：支持非公平（默认）和公平的锁获取方式，吞吐量还是非公平优于公平。
-   可重入：读锁和写锁都支持线程重入。以读写线程为例：读线程获取读锁后，能够再次获取读锁。写线程在获取写锁之后能够再次获取写锁，同时也可以获取读锁。
-   锁降级：遵循获取写锁、再获取读锁最后释放写锁的次序，写锁能够降级成为读锁。

## 2，AQS补充锁设计

**如何实现一把锁的设计**：

AQS + CAS自旋：

自旋一定次数后阻塞，阻塞时state由 0 -> 1，如果考虑性能极致就使用锁，否则直接sychronized

****

