# 正则表达式

## 1，简介

`一个正则表达式就是一个描述规则的字符串, 正则表达式引擎去判断目标字符串是否符合规则。Java标准库的java.util.regex包内置了正则表达式引擎。`



## 2，匹配规则

>   正则表达式的匹配规则是从左到右按规则匹配。在正则表达式字符串中在用到下一个特殊字符之前该子字符串是被看作一个整体的。
>
>   **``(...)`可以用来把一个子规则括起来，子规则可以是字符串或者regex的规则等。`**

### 2.0 特别字符

| 特别字符 | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| \$       | 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 \$ 也匹配 '\n' 或 '\r'。要匹配 $ 字符本身，请使用 \\\$。 |
| ( )      | 标记一个子表达式的开始和结束位置，也是分组。子表达式可以获取供以后使用。要匹配这些字符，请使用 \( 和 \)。 |
| *        | 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \*。     |
| +        | 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+。     |
| .        | 匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \. 。    |
| [        | 标记一个中括号表达式的开始。要匹配 [，请使用 \[。            |
| ?        | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。 |
| \        | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\n' 匹配换行符。序列 '\\' 匹配 "\"，而 '\(' 则匹配 "("。 |
| ^        | 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 \^。 |
| {        | 标记限定符表达式的开始。要匹配 {，请使用 \{。                |
| \|       | 指明两项之间的一个选择。要匹配 \|，请使用 \|。               |

### 2.1 单个字符的匹配规则-单个匹配

>   单个字符可以是单个子规则。

| 正则表达式 | 规则                     | 可以匹配                       |
| :--------- | :----------------------- | :----------------------------- |
| `A`        | 指定字符                 | `A`                            |
| `\u548c`   | 指定Unicode字符          | `和`                           |
| `.`        | 任意字符                 | `a`，`b`，`&`，`0`             |
| `\d`       | 数字0~9                  | `0`~`9`                        |
| `\w`       | 大小写字母，数字和下划线 | `a`~`z`，`A`~`Z`，`0`~`9`，`_` |
| `\s`       | 空格、Tab键              | 空格，Tab                      |
| `\D`       | 非数字                   | `a`，`A`，`&`，`_`，……         |
| `\W`       | 非\w                     | `&`，`@`，`中`，……             |
| `\S`       | 非\s                     | `a`，`A`，`&`，`_`，……         |



### 2.2 多个字符的匹配规则-‘重复匹配’

>   多个字符匹配的限定范围是仅挨着的那个字符或者regex描述的字符。
>
>   即AB{3}描述的不是ABABAB而是ABBB，重复匹配描述的是单个字符，如果想描述多个字符的重复匹配则必须把多个字符看作一个整体（即一个子规则），那么使用括号`（）`
>
>   如：（AB){3} 描述的就是ABABAB

| 正则表达式 | 规则             | 可以匹配                 |
| :--------- | :--------------- | :----------------------- |
| `A*`       | 任意个数字符     | 空，`A`，`AA`，`AAA`，…… |
| `A+`       | 至少1个字符      | `A`，`AA`，`AAA`，……     |
| `A?`       | 0个或1个字符     | 空，`A`                  |
| `A{3}`     | 指定个数字符     | `AAA`                    |
| `A{2,3}`   | 指定范围个数字符 | `AA`，`AAA`              |
| `A{2,}`    | 至少n个字符      | `AA`，`AAA`，`AAAA`，……  |
| `A{0,3}`   | 最多n个字符      | 空，`A`，`AA`，`AAA`     |

### 2.3 复杂匹配规则

| 正则表达式 | 规则                 | 可以匹配                             |
| :--------- | :------------------- | :----------------------------------- |
| ^          | 开头                 | 字符串开头                           |
| $          | 结尾                 | 字符串结束                           |
| [ABC]      | […]内任意字符        | A，B，C                              |
| [A-F0-9xy] | 指定范围的字符       | `A`，……，`F`，`0`，……，`9`，`x`，`y` |
| [^A-F]     | 指定范围外的任意字符 | 非`A`~`F`                            |
| AB\|CD\|EF | AB或CD或EF           | `AB`，`CD`，`EF`                     |



## 3，分组匹配

>   `(...)`可以用来把一个子规则括起来，这样写`learn\s(java|php|go)`就可以更方便地匹配长字符串了。
>
>   实际上`(...)`还有一个重要作用，就是分组匹配。

### 3.1 提前匹配子串

>   `String`提供的`indexOf()`和`substring()`这些方法，但它们从正则匹配的字符串中提取子串没有通用性。正确的方法是用`(...)`先把要提取的规则分组，在从分组中获取。
>
>   `java.util.regex`包，用`Pattern`对象匹配，匹配后获得一个`Matcher`对象，如果匹配成功，就可以直接从`Matcher.group(index)`返回子串。
>
>   index = 0 ：代表所有匹配的字符串
>
>   index = 1：代表第一个分组匹配的字符串
>
>   index = 2：代表第二个分组匹配的字符串
>
>   ......



## 4，非贪婪匹配 

案例：给定一个字符串表示的数字，判断该数字末尾`0`的个数。很容易地写出该正则表达式：`(\d+)(0*)` 但是：不符合期望，原因是非贪婪匹配 

| input  | `\d+`    | `0*` |
| :----- | :------- | :--- |
| 123000 | "123000" | ""   |
| 10100  | "10100"  | ""   |
| 1001   | "1001"   | ""   |

>   正则表达式默认使用贪婪匹配：任何一个规则，它总是尽可能多地向后匹配。要让`\d+`尽量少匹配，让`0*`尽量多匹配，我们就必须让`\d+`使用非贪婪匹配。在规则`\d+`后面加个`?`即可表示非贪婪匹配。
>
>   得到：

| input  | `\d+`  | `0*`  |
| :----- | :----- | :---- |
| 123000 | "123"  | "000" |
| 10100  | "101"  | "00"  |
| 1001   | "1001" | ""    |

`因此，给定一个匹配规则，加上`?`后就变成了非贪婪匹配。`



## 5，搜索和替换

-   分割字符串：`String.split()`
-   搜索子串：`Matcher.find()`
-   替换字符串：`String.replaceAll()`

